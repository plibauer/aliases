##################################################################################################################
#                                                                                                                #
#     ELASTICSEARCH/elasticsearch Specific aliases                                                               #
#     This file should only be read once.                                                                        #
#                                                                                                                #
##################################################################################################################

alias elastichelp      'echo                                                            \\
"                                                                                       \\
For elastic search commands : eshelpsearch                                              \\
For curl commands, see : escurlhelp                                                     \\
For auto-classification commands, see : esautohelp                                      \\
                                                                                        \\
---      Basics        ---                                                              \\
  esinfo              : Show the current configuration                                  \\
  eshost <host:port>  : Set the default host server and port                            \\
  esindex <name>      : Set the default index                                           \\
                                                                                        \\
---   Elastic Index    ---                                                              \\
  mapping        : Show mapping for the default elastic index                           \\
  espym \042index\042  : Show mapping for \042index\042                                 \\
  settings       : Show settings for default index                                      \\
  espys \042index\042  : Show settings for \042index\042                                \\
  espyhelp(espyh): See examples of extended espy commands                               \\
  esindexproperties : Show index properties                                             \\
  esmetadata        : Show metadata fields (use 'metadata' for brief output)            \\
"                                                                                       \\
'

alias eshelpsearch      'echo                                                           \\
"                                                                                       \\
For elastic help : elastichelp (or eshelp)                                              \\
                                                                                        \\
------ Using IDs -------                                                                \\
  docid <id>          : print doc with given id                                         \\
  contents <id>       : print the Document.Content field for given id as original text  \\
  recid <number>      : print doc with record number (\042REC_\042 is prefixed)         \\
  allids              : print every elastic document id found                           \\
  delid <id>          : delete the doc with given id                                    \\
                                                                                        \\
------- Content --------                                                                \\
  NOTE: contentsrch and phrasesrch will print the actual contents of the document,      \\
        converting \042\\n\042 into newlines, whereas the 'trim' variants return the metadata  \\
        documents                                                                       \\
                                                                                        \\
  content <id>        : print all the child Document.Content fields for parent id       \\
  contentsrch         : Search for term(s) in child Document.Content fields             \\
  contentsrchids      : Search for term(s) in Document.Content and return the ids       \\
  phrasesrch          : Search for a phrase in child Document.Content fields            \\
  phrasesrchids       : Search for a phrase in Document.Content and return the ids      \\
  ---                                                                                   \\
  trimcontent         : Search in Document.Content with same query syntax as TRIM       \\
  trimcontentids      : As above, but return the URIs                                   \\
  not_trimcontent     : As above, but negated                                           \\
  not_trimcontentids  : As above, but return the URIs                                   \\
  ---                                                                                   \\
  trimphrase          : Search in Document.Content as above, but perform a phrase search\\
  trimphraseids       : As above, but return the URIs                                   \\
  not_trimphrase      : As above, but negated                                           \\
  not_trimphraseids   : As above, but return the URIs                                   \\
                                                                                        \\
------- books -------                                                                   \\
booktitles            : Print URIs => Title Acronym and vice versa                      \\
booktitlesv           : Print URIs, Acronym and Title                                   \\
docid2acronym         : Pipe output of commands that return a list of URIs to this      \\
                        command to convert them to acronyms                             \\
toacronyms,getacronyms: Same as above                                                   \\
                                                                                        \\
                                                                                        \\
------- Metadata -------                                                                \\
  metadatasrch        : Search on a metadata field (eg. Notes:spoon). Spaces need to be \\
                        encoded as %20, Eg. Notes:spoon%20AND%20Title:refresh           \\
  metasearch          : Same as above                                                   \\
  hasallcontacts      : Show records with the field \042AllContacts\042                 \\
  hasclassification   : Show records with the field \042Classification\042              \\
  hascontainer        : Show records with the field \042Container\042                   \\
  hascontent          : Show records with the field \042Document.Content\042            \\
  hascontenttrim      : As above, but only shows parent URIs, not child documents       \\
  withandwithout      : Shows output of above with the gaps in a second column          \\
  hasexternalref      : Show records with the field \042ExternalReference\042           \\
  hasnotes            : Show records with the field \042Notes\042                       \\
  containers          : Show container records with their contained records             \\
  esgetfield <arg>    : Show the document id and field specified by <arg> (eg Title)    \\
  esrectypes          : Show record uris and their associated record types              \\
"                                                                                       \\
'

alias esautohelp      'echo                                                             \\
"                                                                                       \\
For curl commands, see : escurlhelp                                                     \\
For elastic search commands, see : elastichelp (or eshelp)                              \\
                                                                                        \\
To build the auto-classification dataset, run the following commands;                   \\
   popdbac - runs podpb with --dbid AC and --dbname elastic_autoclass                   \\
   saveac  - save the dataset with above data                                           \\
   testac  - runs testttrim with above for autoclassification test --all and then       \\
             call saveac                                                                \\
   restoreac - load the above saved data                                                \\
                                                                                        \\
buildac is a shortcut to run both popdbac and testac                                    \\
                                                                                        \\
--- Autoclassification ---                                                              \\
  acmapping      : Show mapping for the autoclassification index                        \\
  acsettings     : Show settings for autoclassification index                           \\
  autoclassinfo  : Show a summary of the autoclassification index                       \\
  autoclasstypes : Show the different table <types>                                     \\
  estype <type>  : Query one of the types from the previous command                     \\
  aclabels       : Print _id, document count, uri and name for all categories/labels    \\
                                                                                        \\
---   Word statistics  ---                                                              \\
                                                                                        \\
  getwords \042id\042  <arg1> <arg2> <arg3>                                             \\
             Print tabulated words using _id from acwordlabels                          \\
                                                                                        \\
      ARG1  - search string which will be matched against each pair                     \\
              Eg. \042^un\042 will only match words beginning with \047un\047           \\
      ARG2  - number of columns (default 10)                                            \\
      ARG3  - size of columns (default 30)                                              \\
                                                                                        \\
  If all words should be printed, but you want to change arg2 or arg3, then;            \\
  getwords \042^.+\042 8 25   (all words with 8 columns and col width 25)               \\
                                                                                        \\
Manipulate word counts and test classification process                                  \\
                                                                                        \\
  testac --inplace --classify --input \042hockey science ...\042 --debug > output.txt   \\
  espy --ac_analyse output.txt                                                          \\
             With the WGS running, run testtrim with the text input and see how         \\
             terms are scored.  Feed the output into espy to analyse the results        \\
                                                                                        \\
  espy --ac_modify 9000000018:zubkoff:1                                                 \\
             Change the word count for \047zubkoff\047 to a value of 1. Changing        \\
             a value to 0 will remove the word for the given label.                     \\
                                                                                        \\
"                                                                                       \\
'

alias eshelp elastichelp
alias helpelastic elastichelp

alias espyhelp      'echo                                                                       \\
"                                                                                               \\
  espy           Show all indexes and assign integer value to each index                        \\
  espy \047index\047   Show info for specific index (can use an integer for \047index\047)      \\
                                                                                                \\
  espy s/5/q:a   (long form: search/5/query:all)                                                \\
                 Search(s) the 5th index and Query(q) All(a)                                    \\
                                                                                                \\
  espy s/5/9000000020  (long form: search/5/9000000020)                                         \\
                 Show document with _id (uri) 9000000020                                        \\
                                                                                                \\
  espy s/5       (long form: search/5)                                                          \\
                 Show top 10 documents for index 5                                              \\
                                                                                                \\
  espy s/5 -s Number:Title                                                                      \\
                 As above but only show Number and Title fields                                 \\
                                                                                                \\
  espy s/5 -s Number:Title --compact                                                            \\
                 As above but remove _index,_score,_source,_type fields                         \\
                                                                                                \\
  espy s/5 -e Document                                                                          \\
                 Exclude \047Document\047 from the _source properties                           \\
                                                                                                \\
  espy s/cm_m1 --brief --size 100                                                               \\
                 Get the first 100 documents with 1 entry per line (_id,_sore,Title)            \\
                                                                                                \\
  espy s/cm_m1/query:Notes:\042patterson\042 -s Notes --compact                                 \\
                 Search all \047Notes\047 fields in cm_m1 for the string \047patterson\047 and  \\
                 limit the output to only the \047Notes\047 field                               \\
                                                                                                \\
  espy s/cm_m1/q:Document.Content:trim -s Document --compact                                    \\
                 Search in the document content field for all occurrences of \047trim\047       \\
                 and limit the output to only the \047Document.Content\047 field                \\
                                                                                                \\
  espy s/cm_m1/q:Document.Content:trim --brief                                                  \\
                 As above, but just print the matching URIs                                     \\
\n\n"                                                                                           \\
'


alias elasticblog         'vi $CLOUD_DIR/Work/elastic.txt; scrub $CLOUD_DIR/Work/elastic.txt' 
alias eblog               elasticblog
alias esinstall           '$ELASTIC_HOME/bin/elasticsearch-service.bat install'
alias esstart             '$ELASTIC_HOME/bin/elasticsearch-service.bat start'
alias esdemo              '$ELASTIC_HOME/bin/elasticsearch.bat'
alias esstop              '$ELASTIC_HOME/bin/elasticsearch-service.bat stop'
alias esremove            '$ELASTIC_HOME/bin/elasticsearch-service.bat remove'
alias esmanage            '$ELASTIC_HOME/bin/elasticsearch-service.bat manager'
alias esconfig            'cat $ELASTIC_HOME/config/elasticsearch.yml'
alias goes                'cd $ELASTIC_HOME'
alias elasticup           'usingport 9200'
alias elasticstatus       'elasticup; kibanaup'
alias esstatus            elasticstatus
alias eshost              'elastichost http://\!^'
alias eshostlocal         'elastichost http://localhost:9200'
alias esindex             elasticindex
alias esdefault           elasticdefault

alias setelasticservice  'set elastic_service_name =        \\
`sc query type= service state= all |                        \\
$PERL -ne "                                                 \\
  if (/^SERVICE_NAME: (elasticsearch-service.+)/i){         \\
    s/^SERVICE_NAME: //;                                    \\
    s/\n//;                                                 \\
    print;                                                  \\
  } "`'
alias startelasticsvc     'setelasticservice  && sc start $elastic_service_name'
alias stopelasticsvc      'setelasticservice  && sc stop $elastic_service_name'

# Kibana
alias kibana              '$KIBANA_HOME/bin/kibana.bat && settitle2str KIBANA'
alias kibanaconfig        'cat $KIBANA_HOME/config/kibana.yml'
alias gokibana            'cd $KIBANA_HOME'
alias kibanaup            'usingport 5601'

# Logstash
alias gologstash          'cd $LOGSTASH_HOME'
alias logstash            '$LOGSTASH_HOME/bin/logstash.bat'

# Beats
alias gobeats             'cd $BEATS_HOME'
alias filebeat            '$BEATS_HOME/filebeat.exe'

# Format JSON document using single quotes for C++ string definitions
alias jsonsingle          'cat \!^ | $PERL -ne '"'"' s/"/\047/g; print '"'"
alias cleanjson           '$PERL -ne '"'"'  s/\\//g; print '"'"

set CURL = "curl -s"
set ELASTIC_QUERIES = $env_alias_dir/elastic_queries.txt

# Querying Elastic
alias elasticversion      '$CURL \!^ | grep number | sed -E '"'"' s/number/VERSION/; s/[\",]//g; s/^\s+//; '"'"
alias esversion           'elasticversion $var_elasticHost' 
alias esget               '$CURL "$var_elasticHost/\!^"'
alias escurl              'esget \!^?pretty=true'
alias esgetp              'esget \!^?pretty=true'
alias esgetaliases        'esget _aliases?pretty=true'
alias elasticindexes      '$CURL "\!^/_cat/indices?v&s=index"'
alias esindexesv          'elasticindexes $var_elasticHost'
alias esindexes           'elasticindexes $var_elasticHost | $PERL -ne '"'"' chomp; if(/^\w+\s+\w+\s+\.\w+/){}else{print "$_\n"} '"'"
alias getindexes          esindexes
alias indexes             esindexes
alias indices             esindexes
alias esstats             'esgetp _stats'
alias esgetsettings       'esget \!^/_settings?pretty'
alias essettings          'esgetsettings $var_elasticIndex'
alias settings            esgetsettings
alias setting             'esget \!^/_settings?pretty'
alias esmappings          'esget $var_elasticIndex/_mappings?pretty'
alias mapping             'esget \!^/_mappings?pretty'
alias estemplate          'esget _template/cm-template-$var_elasticIndex?pretty'
alias estemplateraw       'esget _template/cm-template-$var_elasticIndex'
alias estemplatemapping   '(echo cm-template-$var_elasticIndex && estemplateraw )                               \\
 | $PERL -e '"'"'                                             \\
use strict;                                                   \\
use JSON;                                                     \\
                                                              \\
my @in = <>;                                                  \\
my $template = shift @in;                                     \\
chomp $template;                                              \\
my $input = shift @in;                                        \\
                                                              \\
my $j = JSON->new->allow_nonref;                              \\
my $parsed = $j->decode($input);                              \\
#print $j->pretty->encode($parsed->{$template}{"mappings"});  \\
my $map = $parsed->{$template}{"mappings"}{properties};       \\
                                                              \\
my %mapping;                                                  \\
my $max = 15;                                                 \\
for (sort keys %$map){                                        \\
   $max = $max > length($_) ? $max : length($_);              \\
   if($map->{$_}{type}){                                      \\
     $mapping{$_} = $map->{$_}{type};                         \\
   }                                                          \\
   else {                                                     \\
     $mapping{$_} = "";                                       \\
   }                                                          \\
}                                                             \\
                                                              \\
for(sort keys %mapping){                                      \\
  my $sp = " " x ($max - length($_) + 1);                     \\
  print $_.$sp.": ".$mapping{$_}."\n";                        \\
}                                                             \\
'"'"

alias esindexproperties   'esget $var_elasticIndex.properties/_doc/_properties?pretty'
alias indexproperties     esindexproperties
alias esindexmetadata     'esget $var_elasticIndex.properties/_doc/_metadata?pretty'
alias metadata            'esindexmetadata                          \\
| $PERL -e '"'"'                                                    \\
use strict; use JSON;                                               \\
my @input = <>;                                                     \\
my ($max1,$max2,$max3,$max4) = (15,5,8,8);                          \\
my %fields;                                                         \\
my $j = JSON->new;                                                  \\
my $parsed = $j->decode("@input");                                  \\
#print $j->pretty->encode($parsed->{"_source"}{Metadata});          \\
my $meta = $parsed->{"_source"}{Metadata};                          \\
for(keys %$meta){                                                   \\
    my $typ = $meta->{$_}{ElasticType};                             \\
    my $isdef = $meta->{$_}{IsDefault} ? "true" : "false";          \\
    my $enabled = $meta->{$_}{Enabled} ? "true" : "false";          \\
    my $pid = $meta->{$_}{PropertyOrFieldID};                       \\
                                                                    \\
    $max1 = length($_) > $max1 ? length($_) : $max1;                \\
    $max2 = length($pid) > $max2 ? length($pid) : $max2;            \\
    $max3 = length($typ) > $max3 ? length($typ) : $max3;            \\
                                                                    \\
    $fields{$_} = [$typ, $enabled, $isdef, $pid];                   \\
}                                                                   \\
                                                                    \\
++$max1; ++$max2; ++$max3;                                          \\
my $n = "NAME";                                                     \\
my $s = " " x ($max1 - length($n));                                 \\
my $i = "ID";                                                       \\
my $s1 = " " x ($max2 - length($i));                                \\
my $t = "TYPE";                                                     \\
my $s2 = " " x ($max3 - length($t));                                \\
my $title = $n.$s.$i.$s1.$t.$s2."DEFAULT ENABLED";                  \\
my $len = length($title);                                           \\
                                                                    \\
print $title."\n".("-" x $len)."\n";                                \\
                                                                    \\
for(sort keys %fields) {                                            \\
  my($typ,$enab,$def,$prop) = @{$fields{$_}};                       \\
  $s = " " x ($max1 - length($_));                                  \\
  $s1 = " " x ($max2 - length($prop));                              \\
  $s2 = " " x ($max3 - length($typ));                               \\
  my $s3 = " " x ($max4 - length($def));                            \\
  print "$_$s$prop$s1$typ$s2$def$s3$enab\n";                        \\
}                                                                   \\
'"'"

alias essearchall         'esgetp _search'
alias essearch            'esgetp $var_elasticIndex/_search'
alias searchindex         'esgetp \!^/_search'
alias esdelete            '$CURL -X DELETE "$var_elasticHost/\!^"'
alias esrefresh           '$CURL -X POST "$var_elasticHost/_refresh?pretty=true"'
alias docid               '$CURL "$var_elasticHost/$var_elasticIndex/_search?q=_id:\!^&pretty=true"'
alias recid               '$CURL "$var_elasticHost/$var_elasticIndex/_search?q=Number:REC_\!^&pretty=true"'
alias metadatasrch        '$CURL "$var_elasticHost/$var_elasticIndex/_search?q=(\!^)&size=1000&pretty=true"'
alias metasearch          metadatasrch

alias contents            'docid \!^     \\
| $PERL -ne '"'"'                        \\
if(/^\s+\"Content\"\s+:\s+\"(.+)\",$/){  \\
  @l=split /\\n/, $1;                    \\
  for(@l){                               \\
    s/\\"/"/g;                           \\
    print "$_\n";                        \\
  }                                      \\
}  '"'"

alias containers          'eshasfield_withsrc Container  \\
| $PERL -e '"'"'                                         \\
@in = <>;                                                \\
while(my $l = shift @in) {                               \\
  $cont = $uri = "";                                     \\
  if($l =~ /"_source"/){                                 \\
    $l = shift @in;                                      \\
    while($l and $l !~ /"_source"/) {                    \\
      if($l =~ /"Container":\s+(\d+)/i) {                \\
        $cont = $1;                                      \\
      }                                                  \\
      elsif($l =~ /"Uri":\s+(\d+)/i) {                   \\
        $uri = $1;                                       \\
      }                                                  \\
      $l = shift @in;                                    \\
    }                                                    \\
    push @{$containers{$cont}}, $uri;                    \\
    if($l =~ /"_source"/){                               \\
      unshift @in, $l;                                   \\
    }                                                    \\
  }                                                      \\
}                                                        \\
for(sort keys %containers) {                             \\
  $k = $_;                                               \\
  print "$k:\n";                                         \\
  for(sort @{$containers{$k}}) {                         \\
    print "\t$_\n";                                      \\
  }                                                      \\
}                                                        \\
'"'"

alias esdeldocid          '$CURL -XDELETE "$var_elasticHost/$var_elasticIndex/_doc/\!^"'
alias delxx               'setenv ES_DOCID \!^; perl -e '"'"' $id=$ENV{ES_DOCID}; if($id =~ /^(\d+)\.\d+\.\d+$/){ $id .= "?routing=$1";} open F,">C:/tmp/perl_env.txt" or die; print F "set ES_DOCID = \"$id\"\n"; close F; '"'  ; unsetenv ES_DOCID "
alias deldoc              'delxx \!^; source C:/tmp/perl_env.txt; esdeldocid $ES_DOCID '
alias delid               'delxx \!^; source C:/tmp/perl_env.txt; esdeldocid $ES_DOCID '

alias pycurl		      '$PYTHON_CYG $PYTHON_HOME/curl.py'
alias pycurldef	          'pycurl -u "$var_elasticHost/$var_elasticIndex" -a "_search?pretty"'
alias pyc		          'pycurldef  -i -s; cat /c/tmp/pycurl_output.txt'
alias esquery             'pycurldef \!^' 
alias esqueryi            'pycurldef -i' 
alias esquerystring       'pycurldef -q'
alias esqs                esquerystring
alias qs                  esqs

alias escommand           'pycurldef -f $ELASTIC_QUERIES'
alias escommand_debug     'pycurldef -d -f $ELASTIC_QUERIES'
alias eshasfield          'escommand -c field_exists \!^ | grep _id | sort | $PERL -ne '"'"' s/^.+:\s*"([^"]+)".+$/$1/; chomp; print "$_\n"; '"'"
alias eshasfield_withsrc  'escommand --source -c field_exists \!^' 
alias hasclassification   'eshasfield Classification' 
alias hascontainer        'eshasfield Container' 
alias hascontent          'eshasfield Document.Content' 
alias hascontenttrim      'eshasfield Document.Content | $PERL -e '"'"' @i=<>; for(@i){ chomp; s/^(\d+)\..+$/$1/; $u{$_}=1;} for(sort {$a<=>$b} keys %u){print "$_\n"} '"'" 
alias withandwithout      'hascontenttrim       \\
 | $PERL -e '"'"'                               \\
@in = <>;                                       \\
$current = 0;                                   \\
for(@in){                                       \\
  chomp;                                        \\
  if($current) {                                \\
     $next = $current + 1;                      \\
     if($next == $_){                           \\
       print "$_\n";                            \\
     }                                          \\
     else {                                     \\
       $prev = $_ - 1;                          \\
       $sp = " " x length($current);            \\
       if($next == $prev) {                     \\
         $missing = "$sp$next";                 \\
       }                                        \\
       else {                                   \\
         $diff = $prev - $next;                 \\
         $missing = "$sp$next -> $prev ($diff)";\\
       }                                        \\
       print " $missing\n$_\n";                 \\
     }                                          \\
  }                                             \\
  else { print "$_\n" }                         \\
  $current = $_;                                \\
}                                               \\
'"'"

alias hasexternalref      'eshasfield ExternalReference' 
alias hasnotes            'eshasfield Notes' 
alias hasallcontacts      'eshasfield AllContacts'
alias allids              'escommand -c match_all | grep _id | sort'
alias esalldocs           allids
alias esgetfield          '(echo \!^ && escommand -c get_field \!^)  \\
 | $PERL -e  '"'"'                                             \\
                                           \\
@in = <>;                                  \\
$field = shift @in;                        \\
chomp $field;                              \\
$suffix = $field;                          \\
$suffix =~ s/^.+\.([^.]+)$/$1/;            \\
#print "FIELD: $suffix\n";                 \\
for(@in){                                  \\
  chomp;                                   \\
  if(/"_id"\s*:\s*"([^"]+)",/){            \\
    print "$1\t";                          \\
  }                                        \\
  elsif(/^\s+"$suffix"\s*:\s*(.+)$/i) {    \\
    $val = $1;                             \\
    #$val =~ s/^"//;                        \\
    #$val =~ s/"$//;                        \\
    print "$val\n";                        \\
  }                                        \\
}                                          \\
'"'" 

alias titles              'esgetfield Title | sort'
alias booktitlesv         'esgetfield Title | sort       \\
| $PERL -ne '"'"'                                        \\
/^(\d+)\s+"([^"]+)"/i and do {             \\
  if ($1 >= 9000000500) {                                \\
    ($u,$t) = ($1,$2);                                   \\
    $a = $t;                                             \\
    $a =~ s/[^A-z ]//g;                                  \\
    $a =~ s/(\w)\w+/$1/g;                                \\
    $a =~ s/ //g;                                        \\
    $a =~ s/^(...).+$/$1/g;                              \\
    $a = uc $a;                                          \\
    print "$u\t$a\t$t\n";                                \\
  }                                                      \\
}                                                        \\
'"'"

alias booktitles          'booktitlesv                          \\
 | $PERL -e '"'"'                                               \\
  @in = <>;                                                     \\
  my $acr;                                                      \\
  for(@in) {                                                    \\
    chomp;                                                      \\
    if(/^(\d+)\s+(\w+)/) {                                      \\
      ($u,$a) = ($1,$2);                                        \\
      push @col1, "$u\t$a\t";                                   \\
      $acr{$a} = $u;                                            \\
    }                                                           \\
  }                                                             \\
  print "\nOrder by URI\t\t|\tOrder by Acronym\n";              \\
  print "--------------------------------------------------\n"; \\
  @acrons = sort keys %acr;                                     \\
  for($i=0; $i <= $#col1; $i++) {                               \\
    $ac = $acrons[$i];                                          \\
    print $col1[$i]."|\t".$ac."\t".$acr{$ac}."\n";              \\
  }                                                             \\
'"'"

alias capture_input    '$PERL -e '"'"'                            \\
@in=<>;                                                           \\
open T, ">C:/temp/xxx.txt" or die "Couldnt open /c/temp/xxx.txt"; \\
for(@in){                                                         \\
  print T $_;                                                     \\
} '"'" 

alias docid2acronym    'capture_input && booktitlesv > /c/temp/booktitles.txt;   \\
$PERL -e '"'"'                                                                   \\
                                                                                 \\
   open IN, "C:/temp/xxx.txt" or die "Couldnt read /c/temp/xxx.txt";             \\
   @input = <IN>;                                                                \\
   close IN;                                                                     \\
                                                                                 \\
   for(@input){                                                                  \\
     chomp;                                                                      \\
     s/\s+//;                                                                    \\
     $docids .= "$_,";                                                           \\
   }                                                                             \\
   chop $docids;                                                                 \\
                                                                                 \\
  open F, "C:/temp/booktitles.txt" or                                            \\
      die "Couldnt read /c/temp/booktitles.txt\n";                               \\
  @in = <F>;                                                                     \\
  for(@in){                                                                      \\
    chomp;                                                                       \\
    if(/^(\d+)\s+(\w+)/){                                                        \\
       $uri{$1} = $2;                                                            \\
    }                                                                            \\
  }                                                                              \\
                                                                                 \\
  %ids = map { s/^(\d+).*$/$1/; $_ => 1 } split /,/, $docids;                    \\
                                                                                 \\
  for(keys %ids){                                                                \\
    if(exists $uri{$_}) { $valid{$_} = 1; }                                      \\
  }                                                                              \\
  $COUNT = scalar(keys %valid);                                                  \\
                                                                                 \\
  for(keys %uri){                                                                \\
    if(not exists $valid{$_}){                                                   \\
      $missing .= $uri{$_}.",";                                                  \\
      push @missSorted, $uri{$_};                                                \\
    }                                                                            \\
  }                                                                              \\
  $missing =~ s/,$//;                                                            \\
  $miss_sort = join ",", sort @missSorted;                                       \\
  $COUNT_NOMATCH = scalar(@missSorted);                                          \\
                                                                                 \\
  $acr = join ",", sort map { $uri{$_} } (keys %valid) ;                         \\
  $acrbyid = join ",", map { $uri{$_} } (sort keys %valid) ;                     \\
  $uribyid = join "\n", map { "$_\t".$uri{$_} } (sort keys %valid);              \\
  $acr =~ s/^,|,$//;  $acrbyid =~ s/^,|,$//;                                     \\
  $acr =~ s/,+/,/g;   $acrbyid =~ s/,+/,/g;                                      \\
  #print "\n$acr\n\n"; print "ORDERED BY ID:\n$acrbyid\n\n";                     \\
                                                                                 \\
  print "\nMatched: $COUNT (unmatched $COUNT_NOMATCH)\n".                        \\
          "Matches: $acr\n".                                                     \\
          "By ID  : $acrbyid\n\n$uribyid\n";                                     \\
                                                                                 \\
  if($missing ne ""){                                                            \\
    print "\n[Count      : $COUNT_NOMATCH]\n";                                   \\
    print   "[NOT MATCHED: $missing]\n";                                         \\
    print   "[SORTED     : $miss_sort]\n";                                       \\
  }                                                                              \\
'"'"
alias getacronyms           docid2acronym
alias toacronyms            docid2acronym

alias bookdates           '(booktitlesv && esgetfield DateCreated)  \\
 | $PERL -e '"'"'                         \\
while(<>){                                \\
  chomp;                                  \\
                                          \\
  if(/^(\d+)\s+(\w+)\s+(\w.+)$/) {        \\
    my($u,$a,$t) = ($1,$2,$3);            \\
    $title{$u} = $t;                      \\
  }                                       \\
  elsif(/^(\d+)\s+"([^"]+)"/){            \\
    my($u,$d) = ($1,$2);                  \\
    $date{$u} = $d;                       \\
    $byDate{$d} = $u;                     \\
  }                                       \\
}                                         \\
                                          \\
for(sort keys %title){                    \\
  my $date = $date{$_};                   \\
  print "$_  $date  $title{$_}\n";        \\
}                                         \\
print "\n---- BY DATE ----\n\n";          \\
for(sort keys %byDate){                   \\
  my $uri = $byDate{$_};                  \\
  if(exists $title{$uri}){                \\
    my $title = $title{$uri};             \\
    print "$_  $uri  $title\n";           \\
  }                                       \\
}                                         \\
'"'"

alias doccontent          'escommand -c get_record_content \!^ \\
 | $PERL -ne '"'"'            \\
if(/\\n/) {                   \\
  @m = split /\\n/;           \\
  for(@m) {                   \\
    s/\\"/"/g;                \\
    print "$_\n";             \\
  }                           \\
}                             \\
else { print }                \\
'"'"

alias content             doccontent
alias getcontent          doccontent

alias contentsrch         '$CURL "$var_elasticHost/$var_elasticIndex/_search?q=(Document.Content:\!^)&size=1000&pretty=true" \\
 | $PERL -ne '"'"'            \\
if(/\\n/) {                   \\
  @m = split /\\n/;           \\
  for(@m) {                   \\
    s/\\"/"/g;                \\
    print "$_\n";             \\
  }                           \\
}                             \\
else { print }                \\
'"'"


alias contentsrchids          '$CURL "$var_elasticHost/$var_elasticIndex/_search?q=(Document.Content:\!^)&size=1000&_source=false&pretty=true" \\
| $PERL -ne '"'"'                          \\
chomp;                                     \\
/"_id"\s*:\s*"([\d\.]+)/ and do            \\
{ print "$1\n"; }                          \\
'"' | sort " 

alias searchcontents      contentids

alias phrasesrchids      'escommand --size 1000 -c search_content_phrase \!^ \\
 | $PERL -ne '"'"'                         \\
chomp;                                     \\
/"_id"\s*:\s*"([\d\.]+)/ and do            \\
{ print "$1\n"; }                          \\
'"' | sort "

alias phrasesrch         'escommand --source --size 1000 -c search_content_phrase \!^ \\
| $PERL -ne '"'"'          \\
if(/\\n/) {                \\
  @m = split /\\n/;        \\
  for(@m) { print "$_\n"; }\\
}                          \\
else { print }             \\
'"'"

alias trimcontent         'escommand --source --size 1000 -c search_record_content \!^'
alias trimcontentids      'escommand --size 1000 -c search_record_content \!^ \\
| grep _id | sort | $PERL -ne '"'"' s/\D//g; print "$_\n"; '"'"

alias trimphrase          'escommand --source --size 1000 -c search_record_content_phrase \!^'
alias trimphraseids       'escommand --size 1000 -c search_record_content_phrase \!^ \\
| grep _id | sort | $PERL -ne '"'"' s/\D//g; print "$_\n"; '"'"

alias not_trimcontent     'escommand --source --size 1000 -c not_search_record_content \!^'
alias not_trimcontentids  'escommand --size 1000 -c not_search_record_content \!^ \\
| grep _id | sort | $PERL -ne '"'"' s/\D//g; print "$_\n"; '"'"

alias not_trimphrase     'escommand --source --size 1000 -c not_search_record_content_phrase \!^'
alias not_trimphraseids  'escommand --size 1000 -c not_search_record_content_phrase \!^ \\
| grep _id | sort | $PERL -ne '"'"' s/\D//g; print "$_\n"; '"'"

alias esrectypes          'eshasfield_withsrc RecordType | egrep "_id|RecordType" \\
| $PERL -e '"'"'                            \\
@in = <>;                                   \\
while(my $l = shift @in) {                  \\
  chomp $l;                                 \\
  if($l =~ /"_id":\s+"(\d+)/) {             \\
    $uri = $1;                              \\
    $l = shift @in;                         \\
    chomp $l;                               \\
    if($l =~ /RecordType":\s+(\d+)/) {      \\
      $rectypes{$uri} = $1;                 \\
    }                                       \\
  }                                         \\
}                                           \\
for (sort {$a<=>$b} keys %rectypes) {       \\
  print "$_ => RecordType $rectypes{$_}\n"; \\
}                                           \\
'"'"


# Delete a document/record and its children
alias esdelparentchild    'escommand -c delete_children \!^ && esdeldocid \!^'

alias elasticinfo         'echo "HOST    : $var_elasticHost"; echo "INDEX   : $var_elasticIndex"; esversion; echo; indexes'  
alias esinfo              elasticinfo
alias esenv               'echo "HOST    : $var_elasticHost"; echo "INDEX   : $var_elasticIndex"'
alias curlh               '$CURL "$var_elasticHost/\!^"'

alias curl5               '$CURL "$ELASTIC_HOST5/\!^"'
alias curldel5            '$CURL -X DELETE "$ELASTIC_HOST5/\!^"'  
alias eshost5             'elastichost $ELASTIC_HOST5'
alias esinfo5             'echo "HOST    : $ELASTIC_HOST5"; elasticversion $ELASTIC_HOST5; elasticindexes $ELASTIC_HOST5' 

alias curl6               '$CURL "$ELASTIC_HOST6/\!^"'
alias curldel6            '$CURL -X DELETE "$ELASTIC_HOST6/\!^"'  
alias eshost6             'elastichost $ELASTIC_HOST6'
alias esinfo6             'echo "HOST    : $ELASTIC_HOST6"; elasticversion $ELASTIC_HOST6; elasticindexes $ELASTIC_HOST6' 

alias curl7               '$CURL "$ELASTIC_HOST7/\!^"'
alias curldel7            '$CURL -X DELETE "$ELASTIC_HOST7/\!^"'  
alias eshost7             'elastichost $ELASTIC_HOST7'
alias esinfo7             'echo "HOST    : $ELASTIC_HOST7"; elasticversion $ELASTIC_HOST7; elasticindexes $ELASTIC_HOST7' 

alias espy                '$PYTHON $PYTHON_HOME/elasticClient.py --config $PYTHON_HOME/elastic.config --server $var_elasticHost'
alias espya               'espy "\!^/all"'
alias espym               'espy "\!^/mapping"'
alias espys               'espy "\!^/settings"'

alias acmapping           'espy $var_elasticIndexAC/m'
alias acsettings          'espy $var_elasticIndexAC/s'
alias autoclasstypes      'espy search/$var_elasticIndexAC -s type --compact --size 10000 | grep type | sort | uniq'
alias estype              'espy search/$var_elasticIndexAC/q:type:\!^'

alias aclabels  'espy search/$var_elasticIndexAC/q:type:word_label_counts -e word_count:type --compact --size 10000 \\
| $PERL -e '"'"'                                                   \\
while(<>){                                                         \\
  chomp;                                                           \\
  if(/^_id:(wlc_(\d+)) = \{\s*$/) { $id = $2; $ID{$id} = $1." "; } \\
  elsif(/^\s+"word_count"/) {}                                     \\
  elsif(/^\s+"(count|label|name)"/) { $ID{$id} .= $_; }            \\
  elsif(/^\}/){ $ID{$id} .= "\n"; $id = ""; }                      \\
  else { }                                                         \\
}                                                                  \\
for(sort {$a<=>$b} keys %ID){ print $ID{$_}; }                     \\
exit;                                                              \\
'"'"

alias autoclassinfo  "echo '\nAutoClassification TYPES: \n'; autoclasstypes; echo '\n-------\n' ; aclabels; echo '\n--------\n' "
alias acinfo autoclassinfo

alias elastic_add_wlc_prefix 'set wlcIndex=`echo \!^ | sed -r -e "s/^([[:digit:]])/wlc_\1/"`'

# Provide the _id for the "word_label_counts" entry and format the words into columns
# Takes additional arguments as follows
#  ARG1  - search string which will be matched against each pair
#        Eg. "^un" will only match words beginning with 'un'
#  ARG2  - number of columns (default 10)
#  ARG3  - size of columns (default 30)
#
alias getwords 'setenv AC_SEARCH_STR "\!*"                          \\
&& elastic_add_wlc_prefix \!:1                              \\
&& espy search/$var_elasticIndexAC/$wlcIndex --compact -s word_count        \\
| $PERL -e '"'"'                                    \\
my ($cols, $width) = (10, 30);                                                      \\
@a = split /\s+/, $ENV{AC_SEARCH_STR};                                              \\
#                                                                                   \\
#  We may have added a missing wlc_ prefix using elastic_add_wlc_prefix             \\
my $ind = shift @a; $ind =~ s/^(\d)/wlc_$1/;                                        \\
#                                                                                   \\
my (@tooLong, $out, $outf, @args);                                                  \\
$out = "INDEX: $ind";                                                               \\
for($i=0; $i <= $#a; $i++){                                                         \\
   if($a[$i] eq ">") { $outf = $a[$i + 1]; last; }                                  \\
   @args[$i] = $a[$i];                                                              \\
}                                                                                   \\
                                                                                    \\
if(scalar(@args) >= 1) { $srchStr = $args[0]; $out .= ", SEARCH: \"$srchStr\""; }   \\
if(scalar(@args) >= 2) { $cols    = $args[1]; $out .= ", COLUMNS: $cols"; }         \\
if(scalar(@args) >= 3) { $width   = $args[2]; $out .= ", WIDTH: $width"; }          \\
                                                                                    \\
if($outf) { print "OutputFile => $outf\n"; }                                        \\
                                                                                    \\
$out .= "\n";                                                                       \\
while(<>) {                                                                         \\
  chomp;                                                                            \\
  if(/^\s+"word_count":\s+"(.+)"$/){                                                \\
     @pairs = split /,/, $1;                                                        \\
     $out .= "WORD Count = ".scalar(@pairs)."\n";                                   \\
     $i=1;                                                                          \\
     for(@pairs){                                                                   \\
        if($srchStr) { next unless /$srchStr/; }                                    \\
        if(length($_) >= $width){ push @tooLong, $_; next }                         \\
        $space = " " x ($width - length($_));                                       \\
        $out .= $_.$space;                                                          \\
        ++$i;                                                                       \\
        if($i % $cols == 0){ $out .= "\n"; }                                        \\
     }                                                                              \\
  }                                                                                 \\
}                                                                                   \\
$out .= "\n\n";                                                                     \\
for(@tooLong){ $out .= "$_\n"; }                                                    \\
if($outf) {                                                                         \\
  open OUT, ">$outf" or die "Couldnt open $outf\n";                                 \\
  print OUT $out;                                                                   \\
  close OUT;                                                                        \\
}                                                                                   \\
else { print $out; }                                                                \\
exit;                                                                               \\
'"'" 

alias esprocesslog  'cat \!^ | $PERL -e '"'"'          \\
                                                           \\
while(<>) {                                                \\
  chomp $_;                                                \\
  if (/^[\d:]+\s+[A-z]{2}\s+(\d+)/) {                      \\
     $thread = $1;                                         \\
     push @{$log[$thread]}, "$_\n";                        \\
  }                                                        \\
  else {                                                   \\
    print "$_\n";                                          \\
  }                                                        \\
}                                                          \\
for(my $i=1; $i <= $#log; $i++ ){                          \\
  print "Thread\t$i (".scalar(@{$log[$i]})." entries) \t"; \\
  open T,">Thread_$i.txt" or die;                          \\
  for(@{$log[$i]}){                                        \\
     print T $_;                                           \\
  }                                                        \\
  close T;                                                 \\
  print "=> Thread_$i.txt\n";                              \\
                                                           \\
}                                                          \\
                                                           \\
 print "\nTo get the list of files for a thread;\n\n\t";   \\
 print ">esgetfiles 'Thread_1.txt'\n\n";                   \\
                                                           \\
                                                           \\
'"'"

alias esgetfiles 'cat \!^ | $PERL -e '"'"'                 \\
                                                           \\
while(<>) {                                                \\
  chomp $_;                                                \\
  if (/^([\d:]+)\s+[A-z0-9]{2}\s+(\d+\s+){6}([^\s]+)/) {   \\
     if(not exists $files{$3}) {                           \\
       $files{$3} = 1;                                     \\
       $bytime{$1} = $3                                    \\
     }                                                     \\
  }                                                        \\
}                                                          \\
for(sort keys %bytime){                                    \\
  print "$_\t$bytime{$_}\n";                               \\
}                                                          \\
                                                           \\
                                                           \\
'"'"

