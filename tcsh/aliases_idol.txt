##############################################################################
#
#  IDOL ALIASES
#
#  None of the aliases in this file should need to be re-source after
#  initialisation
#

set IDOL_PROXY = http://localhost:11000
set IDOL_PROXY_IDX = http://localhost:11001
set DEVURL = $IDOL_PROXY/action

##############################################################################
#
#  IDOL HELP INFO

alias idolhelp      'echo                                                                           \\
"\n                                                                                                 \\
---------------------- DATABASE --------------------------------------------------------            \\
idoldbs               : List the currently configured IDOL databases                                \\
idolremovedb          : Remove the default database (eg. CM_M5)                                     \\
\\
---------------------- CONFIGURATION ---------------------------------------------------            \\
idolconfig            : Sets up DBID with suffix 5 and dataset name with suffix \042_idol\042       \\
popdbidol             : Runs popdb for above settings                                               \\
restoreidol           : Restores above database                                                     \\
goidol                : Change directory to Idol Development Deployment                             \\
idolconfig            : View the TRIM IDOL Service configuration file                               \\
idolconfigcontent     : View the TRIM Content Service configuration file                            \\
editidolconfig        : Edit  TRIM IDOL Service configuration file                                  \\
editidolconfigcontent : Edit  TRIM IDOL Content Service configuration file                          \\
idol_log_<type>       : Tail an IDOL log file, eg. idol_log_index                                   \\
                      : <type> one of action, agent, app, cat, query, svc_app                       \\
\\
---------------------- SEARCHING -------------------------------------------------------            \\
idolquery/idolsearch  : Do a content search for a given string                                      \\
idoluri <uri>         : Search for a record with <uri> and print basic fields                       \\
idolcontent <uri>     : Search for a record with <uri> and print all fields and content             \\
idolrec <number>      : Search based on record number, ie. 200 for REC_200                          \\
idolrecv <number>     : Same as above, but print all fields including content                       \\
idolref  <urn>        : Search for a record based on the URN, eg. trim:N5/rec/9000000238:1          \\
                        Use idolcontent if you only want to specify the URI                         \\
idolsave <num/range>  : Save the full IDX in XML format for the given record number/range. Can      \\
                        specify as REC_10, or just 10. A range is \042REC_1 .. REC_10\042 or        \\
                        \042\061 .. 10\042. This is equivalent to the range 9000000001 -> 9000000010.\\
                        The files are saved as 9000000001.txt etc.                                  \\
idolreq <num/range>   : As above, except prints to screen and formats the XML output                \\
\\
idolrectype <uri>     : Search for records that have the Record Type <uri>                          \\
idolrectypev <uri>    : Search as above and print full output                                       \\
\\
dbidol                : Connect to the Idol SqlServer instance using db.pl                          \\
rectypes_idol         : Use dbidol to get RecordTypes                                               \\
classifications_idol  : Use dbidol to get Classifications                                           \\
\\
idolsync              : Send a DRESYNC to the index to make sure all records are available          \\
                                                                                                    \\
---------------------- AUTOCLASSIFICATION ----------------------------------------------            \\
idol_train            : loads training records for above dataset                                    \\
idol_test             : loads test records data for above dataset                                   \\
idol_both             : loads both above sets                                                       \\
idol_classify         : Runs classify on records in Holding Bay                                     \\
                                                                                                    \\
CATEGORY commands                                                                                   \\
idolcatids              : Print all category IDs                                                    \\
idolcaturis             : Print all category names, URIs and IDs                                    \\
idolcat <id>            : Get the category with 'id'                                                \\
idolsuggesturi <uri>    : Suggest a category for the document with uri <uri>                        \\
idoltraining <id>       : Get the data that has been used to train the category                     \\
idolterms <id>          : Get extended term information with 'id'                                   \\
idolcatdel(ete) <id>    : Delete the category with 'id'                                             \\
idolcatdelete_all       : Delete all categories                                                     \\
idolcathier(archy) <id> : Get the hierarchy details for 'id'                                        \\
idolclass <opt>         : Search for categories and print uri, name, urn, database, id and terms    \\
    (a)ll      - show all categories with name, urn, category ID, term count and terms              \\
    (s)ummary  - Show summarised version of categories (no terms shown)                             \\
    uri        - show category matching the 'uri' value                                             \\
    string     - show all categories with names matching the 'string'                               \\
\n\n"                                                                                               \\
'


##############################################################################

alias idolenv          'echo                              \\
"                                                         \\
IDOL Proxy host : $IDOL_PROXY                             \\
Proxy Index URL : $IDOL_PROXY_IDX                         \\
Database        : $var_idolDb (set with idolindex)        \\
DBID            : $var_idolDBID    (set with setdbid  )   \\
"                                                         \\
'
alias idolinfo         'idolenv; idoldbs'

alias goidol           'cd "$IDOL_DIR"'
alias goidolservice    'cd "$IDOL_DIR/TRIM IDOL Service"'
alias goidolcontent    'cd "$IDOL_DIR/TRIM Content Service 1"'

alias idolconfig            'more "$IDOL_DIR/TRIM IDOL Service/TRIM IDOL Service.cfg"'
alias idolconfigcontent     'more "$IDOL_DIR/TRIM Content Service 1/TRIM Content Service 1.cfg"'
alias editidolconfig        'vi "$IDOL_DIR/TRIM IDOL Service/TRIM IDOL Service.cfg"'
alias editidolconfigcontent 'vi "$IDOL_DIR/TRIM Content Service 1/TRIM Content Service 1.cfg"'

alias idolcurl              'curl -XGET "$IDOL_PROXY/\!^"   --noproxy "*" --silent'
alias idolstatus            'curl -XGET "$DEVURL=GetStatus" --noproxy "*" --silent' | $PERL $PERL_HOME/xmlformat.pl

set CURL_OPTS = --silent
set XMLFORMAT = "$PERL $PERL_HOME/xmlformat.pl"
set CURLDEV   = "curl -XGET $DEVURL"
set CURLQUERY = "curl -XGET $DEVURL=query"

alias dresync            'curl "$IDOL_PROXY_IDX/DRESYNC"'
alias idolremovedocs     'curl "$IDOL_PROXY_IDX/DREDELDBASE?DREdbname=\!^"'
alias idolremovedatabase 'curl "$IDOL_PROXY_IDX/DREREMOVEDBASE?DREdbname=\!^"'
alias idolremovedb       'idolremovedatabase $var_idolDb'
alias idolcontent        '$CURLDEV=getcontent\&reference=trim:$var_idolDBID/rec/\!^                  $CURL_OPTS | $XMLFORMAT'
alias idolref            '$CURLDEV=getcontent\&reference=\!^                                         $CURL_OPTS | $XMLFORMAT'
alias idolrecordsdb      '$CURLQUERY\&text=\*\&databasematch=\!^\&MaxResults=999                     $CURL_OPTS | $XMLFORMAT'
alias idolrecords        '$CURLQUERY\&text=\*\&databasematch=$var_idolDb\&MaxResults=\!^             $CURL_OPTS | $XMLFORMAT'
alias idolrecordsall     '$CURLQUERY\&text=\*\&databasematch=$var_idolDb\&MaxResults=1000000         $CURL_OPTS | $XMLFORMAT'
alias idolreference      '$CURLQUERY\&text=\*\&MatchReference=trim:$var_idolDBID/rec/\!^            $CURL_OPTS | $XMLFORMAT'
alias idolreferencev     '$CURLQUERY\&text=\*\&Print=All\&MaxResults=1000\&MatchReference=trim:$var_idolDBID/rec/\!^ $CURL_OPTS | $XMLFORMAT'
alias idolquery          '$CURLQUERY\&text=\!^\&MaxResults=1000\&databasematch=$var_idolDb           $CURL_OPTS | $XMLFORMAT'

#   Need to % encode left and right brackets
#
#     %28 => (   %29 => )
#
alias idolcontentsearch '$CURLQUERY\&databasematch=$var_idolDb\&combine=DREROOTFAMILYREFERENCE\&predict=false\&anylanguage=true\&start=1\&maxresults=100000\&totalresults=true\&storestate=true\&text=%28\!^%29:DRECONTENT       $CURL_OPTS | $XMLFORMAT'
alias idolcontentsearchv '$CURLQUERY\&xmlmeta=true\&databasematch=$var_idolDb\&combine=DREROOTFAMILYREFERENCE\&predict=false\&anylanguage=true\&start=1\&maxresults=100000\&totalresults=true\&storestate=true\&text=%28\!^%29:DRECONTENT       $CURL_OPTS | $XMLFORMAT'

alias idolqueryv        '$CURLQUERY\&text=\!^\&MaxResults=1000\&XMLMeta=true\&databasematch=$var_idolDb $CURL_OPTS | $XMLFORMAT'
alias idolsearchids     'idolcontentsearch \!^ | $PERL -ne '"'"' if(/autn:reference>trim:\w+\/rec\/([\w\:]+)</) { print "$1\n" } '"'"
alias idolsearchtable   'idolcontentsearch \!^ | $PERL -e '"'"'        \\
my @res = <>;                                                          \\
my $line = shift @res;                                                 \\
my (%hits,@weights);                                                   \\
while($line) {                                                         \\
  chomp $line;                                                         \\
  if($line =~ /<autn:hit>/) {                                          \\
    my ($hit,$weight,$title);                                          \\
    $line = shift @res;                                                \\
    while( $line !~ /<\/autn:hit>/ ) {                                 \\
      chomp $line;                                                     \\
      if( $line =~ /<autn:reference>trim:\w+\/rec\/([\w\:]+)</ ) {     \\
         $hit = $1;                                                    \\
      }                                                                \\
      elsif( $line =~ /<autn:weight>([\d+\.]+)</ ) {                   \\
         $weight = $1;                                                 \\
      }                                                                \\
      elsif( $line =~ /<autn:title>(.+)<\/autn:title>/ ) {             \\
         $title = $1;                                                  \\
      }                                                                \\
      $line = shift @res;                                              \\
    }                                                                  \\
    $hits{$hit} = { weight => $weight, title => $title };              \\
    push @weights, { hit => $hit, weight => $weight, title => $title };\\
  }                                                                    \\
                                                                       \\
  $line = shift @res;                                                  \\
  if(scalar(@res) == 0){                                               \\
    last;                                                              \\
  }                                                                    \\
}                                                                      \\
                                                                       \\
for(@weights) {                                                        \\
  print $_->{hit}."\t".$_->{weight}."\t".$_->{title}."\n";             \\
}                                                                      \\
'"'"

#   Need to % encode left and right curly brackets
#
#     %7B => {   %7D => }
#
set IDOLRECQRY = "$CURLQUERY\&text=\*\&MaxResults=1000\&databasematch=$var_idolDb\&FieldText"
alias idoluriv          idolcontent 
alias idoluri           "$IDOLRECQRY=MATCH%7B\!^%7D:TN_URI                                            $CURL_OPTS | $XMLFORMAT"
alias idolrec           "$IDOLRECQRY=MATCH%7BREC_\!^%7D:TS_NUMBER                                     $CURL_OPTS | $XMLFORMAT"
alias idolrecv          "$IDOLRECQRY=MATCH%7BREC_\!^%7D:TS_NUMBER\&Print=All                          $CURL_OPTS | $XMLFORMAT"
alias irt               "$IDOLRECQRY=STRING%7Btrim:$var_idolDBID/rty/\!^%7D:TS_RECORDTYPE\&combine=DREROOTFAMILYREFERENCE $CURL_OPTS | $XMLFORMAT"
alias irtv              "$IDOLRECQRY=STRING%7Btrim:$var_idolDBID/rty/\!^%7D:TS_RECORDTYPE\&print=all  $CURL_OPTS | $XMLFORMAT"

# New python script for querying the proxy server
alias idolrequest	'$PYTHON $PYTHON_HOME/indexRequest.py'
alias idolrequesthelp   'idolrequest -h'
alias idolsave          'idolrequest -a getcontent --all --engine idol --create --dbid $var_idolDBID --recnum'
alias idolreq           'idolrequest -a getcontent --all --engine idol --dbid $var_idolDBID --recnum \!^ | xmlformat'

alias idolrectype       'irt \!^ |   \\
$PERL -e '"'"'                       \\
@in = <>;                            \\
$hits = 0;                           \\
while($_ = shift @in){               \\
  chomp;                             \\
  if(/autn:reference>(.+)<\/autn/){  \\
    print "$1 ";                     \\
    ++$hits;                         \\
    next;                            \\
  }                                  \\
  if(/autn:title>(.+)<\/autn/) {     \\
    print "TITLE: $1\n";             \\
    next;                            \\
  }                                  \\
}                                    \\
if($hits > 3){                       \\
  print "\nTOTAL HITS => $hits\n\n"; \\
}                                    \\
'"'"
alias idolrectypev  irtv

alias idolcategoryrecs  '$CURLQUERY\&MaxResults=1000\&FieldText=STRING%7Btrim:$var_idolDBID\\
/pln/\!^%7D:TS_CLASSIFICATION\&Sort=TD_DATEREGISTERED:alphabetical $CURL_OPTS | $XMLFORMAT'

alias idolcatrecs       'idolcategoryrecs \!^ | perl -e  '"'"'          \\
                                                                        \\
my ($HITS,$success,$recs);                                              \\
my @in = <>;                                                            \\
$success = 0;                                                           \\
for (@in) {                                                             \\
  if(/<response>SUCCESS/){                                              \\
    $success = 1;                                                       \\
    last;                                                               \\
  }                                                                     \\
}                                                                       \\
if(not $success){                                                       \\
  for(@in) {                                                            \\
    print;                                                              \\
  }                                                                     \\
  exit;                                                                 \\
}                                                                       \\
for (@in) {                                                             \\
  chomp;                                                                \\
  if(/numhits>(\d+)</){                                                 \\
    $HITS = $1;                                                         \\
    next;                                                               \\
  }                                                                     \\
  if(/reference>(.+)<\/autn:reference>/){                               \\
    $recs .= "$1  TITLE: ";                                             \\
    next;                                                               \\
  }                                                                     \\
  if(/title>(.+)<\/autn:title>/){                                       \\
    $recs .= "$1\n";                                                    \\
    next;                                                               \\
  }                                                                     \\
}                                                                       \\
print "SUCCESS ($HITS hits):\n\n".$recs;                                \\
'"'"
alias formatidol                '$PERL -e  '"'"'                        \\
my $sortbyweight = $ENV{BYWEIGHT};                                      \\
my @in = <STDIN>;                                                       \\
my (%HITS,%BYWEIGHT,$HITCOUNT,$max);                                    \\
$max = 20;                                                              \\
while (my $line = shift @in) {                                          \\
  chomp $line;                                                          \\
  if($line =~ m|autn:numhits>(\d+)</autn:numhits>|){                    \\
    $HITCOUNT = $1;                                                     \\
    next;                                                               \\
  }                                                                     \\
  if($line =~ m|autn:reference>(.+)</autn:reference>|){                 \\
    my $r = $1;                                                         \\
    $max = $max > length($r) ? $max : length($r);                       \\
    chomp(my $id = shift @in);                                          \\
    $id =~ s/^.+id>(\d+)<.+$/$1/;                                       \\
    my($sec,$wght,$c,$d) = (shift @in, shift @in, shift @in, shift @in);\\
    my $title = $d;                                                     \\
    if($c =~ /autn:links/){                                             \\
       $title = shift @in;                                              \\
    }                                                                   \\
    chomp $title; chomp $wght;                                          \\
    $title =~ s|^.+title>(.+)</autn:title.+$|$1|;                       \\
    $wght =~ s|^.+weight>(.+)</autn:weight.+$|$1|;                      \\
    $HITS{$r}= { id => $id, title => $title, weight => $wght };         \\
    $BYWEIGHT{$wght} = $r;                                              \\
  }                                                                     \\
}                                                                       \\
print "TOTAL HITS: $HITCOUNT\n";                                        \\
my @hits;                                                               \\
if ($sortbyweight eq "true") {                                          \\
  @hits = sort { $HITS{$b}{weight} <=> $HITS{$a}{weight} } keys %HITS;  \\
}                                                                       \\
else {                                                                  \\
  @hits = sort keys %HITS;                                              \\
}                                                                       \\
for(@hits){                                                             \\
  my $i = $HITS{$_};                                                    \\
  my $s = " " x ($max - length($_));                                    \\
  print "  ".$i->{weight}."  ".$i->{id}."  $_$s  ".$i->{title}."\n";    \\
}                                                                       \\
'"'"

alias idolrecs      'unsetenv BYWEIGHT && idolrecords \!^  | formatidol'
alias idolrecsall   'unsetenv BYWEIGHT && idolrecordsall   | formatidol'
alias idolq         'setenv BYWEIGHT true && idolquery \!^ | formatidol'

alias idolsync      dresync

set LOG_CONTENT_DIR = "/e/IDOL Development Deployment/TRIM Content Service 1/logs/application.log"

alias idol_log_app     'tail -f "$IDOL_DIR/TRIM Content Service 1/logs/application.log"'
alias idol_log_index   'tail -f "$IDOL_DIR/TRIM Content Service 1/logs/index.log"'
alias idol_log_query   'tail -f "$IDOL_DIR/TRIM Content Service 1/logs/query.log"'

alias idol_log_cat     'tail -f "$IDOL_DIR/TRIM IDOL Service/logs/category_category.log"'
alias idol_log_svc_app 'tail -f "$IDOL_DIR/TRIM IDOL Service/logs/application.log"'
alias idol_log_agent   'tail -f "$IDOL_DIR/TRIM IDOL Service/logs/agentstore_agent_index.log"'

set ACT_LOG = ": Request (completed in|from)|: Generated ActionId"
alias idol_log_action  'tail -f "$IDOL_DIR/TRIM IDOL Service/logs/action.log" | grep -Eiv "$ACT_LOG"'

alias idol_log_dev_app   'tail -f "$IDOL_DIR/TRIM IDOL Service DEV ONLY/logs/application.log"'
alias idol_log_dev_index 'tail -f "$IDOL_DIR/TRIM IDOL Service DEV ONLY/logs/index.log"'

alias grepilogs     'grep -i \!^ "$IDOL_DIR/TRIM Content Service 1/logs/"*.log && grep -i \!^ "$IDOL_DIR/TRIM IDOL Service/logs/"*.log'
alias grepidol      grepilogs

# Get Idol config for proxy, content or service
alias idolget       'echo \!* | $PERL -e  ' "' "'    \\
                                                                 \\
my %srvs = ( c => 9102, p => 11002, s => 9002 );                 \\
my %desc = ( c => "Content Service",                             \\
             p => "Proxy Service",                               \\
             s => "IDOL Service" );                              \\
my %type = ( c => "GetConfig",                                   \\
             s => "GetStatusInfo",                               \\
             v => "GetStatistics" );                             \\
                                                                 \\
@in = <>;                                                        \\
@args = split /\s+/, shift @in;                                  \\
my $arg1 = lc shift @args;                                       \\
my $arg2 = lc shift @args ;                                      \\
if ($arg1 =~ /^h(elp)$/ or $arg1 !~ /^(c|s|v)/) {                \\
  print <<END;                                                   \\
                                                                 \\
USAGE  : idolget (config|status) [opt]                           \\
OPTIONS:                                                         \\
         h(elp)     : print this usage page                      \\
         c(onfig)   : print the configuration for [opt]          \\
         s(tatus)   : print the status for [opt]                 \\
         v(alues)   : print the statistics for [opt]             \\
[opt]  :                                                         \\
         a(ll)      : all services                               \\
         c(ontent)  : content service                            \\
         p(roxy)    : proxy service                              \\
         s(ervice)  : IDOL service                               \\
END\\
exit;                                                            \\
};                                                               \\
my $url = "http://localhost:XXXX/action=YYYY";                   \\
my $TYPE = "c";                                                  \\
if ($arg1 =~ /^(c|s|v)/) {                                       \\
  $TYPE = $1;                                                    \\
  $url =~ s/YYYY/$type{$TYPE}/;                                  \\
}                                                                \\
if ($arg2 =~ /^(c|p|s)/) {                                       \\
  my $s = $srvs{$1};                                             \\
  $url =~ s/XXXX/$s/;                                            \\
  print "URL : $url\n";                                          \\
  my @results = `curl $url --silent`;                            \\
  print "@results\n";                                            \\
}                                                                \\
elsif ($arg2 =~ /^a/) {                                          \\
  foreach(sort keys %srvs){                                      \\
     my $nurl = $url; my $key = $_;                              \\
     my $s = $srvs{$key};                                        \\
     $nurl =~ s/XXXX/$s/;                                        \\
     my $s = "=" x 20;                                           \\
     print "\n$s $desc{$key}  [$nurl] $s\n\n";                   \\
     my @results = `curl $nurl --silent`;                        \\
     for(@results) {                                             \\
        if(/<ACTION>|\[statusinfo\]|<.responsedata>/i){}         \\
        else { print; }                                          \\
     }                                                           \\
  }                                                              \\
}                                                                \\
else {print "INVALID 2nd Argument : $arg2 ('idolget help')\n";}  \\
'"'"

alias idoldbs               'idolget values content | $PERL -e  '"'"'           \\
my ($max,$REINDEXED,$TOTAL,$NO_DBS);                                            \\
my %dbs; $max = 8; my @in=<>;                                                   \\
while(my $l = shift @in) {                                                      \\
  chomp $l;                                                                     \\
  $l =~ /Indexer.+autnid="Documents".+ReplacedReindex.+value="(\d+)"/i and do { \\
     $REINDEXED = $1; next;                                                     \\
  };                                                                            \\
  $l =~ /Service.+autnid="Documents"\s+name="Total".+value="(\d+)"/i and do {   \\
     $TOTAL = $1; next;                                                         \\
  };                                                                            \\
  $l =~ /Service.+autnid="Databases".+Number.+value="(\d+)"/i and do {          \\
     $NO_DBS = $1; next;                                                        \\
  };                                                                            \\
  $l =~ /class="Database"\s+autnid="(.+)".+Documents.+value="(\d+)"/i and do {  \\
     $dbs{$1} = $2;                                                             \\
     $max = ($max > length($1) ? $max : length($1));                            \\
  };                                                                            \\
}                                                                               \\
my $header = "   DATABASE"." " x ($max - 7);                                    \\
$header .= " | Documents";                                                      \\
my $line = "-" x length($header);                                               \\
print <<DBS;                                                                    \\
                                                                                \\
Total Databases : $NO_DBS                                                       \\
Total Documents : $TOTAL                                                        \\
Re-indexed Docs : $REINDEXED                                                    \\
                                                                                \\
$header                                                                         \\
$line                                                                           \\
DBS\\
for(sort keys %dbs) {                                                           \\
  my $s = " " x ($max - length($_));                                            \\
  print "    $_$s : $dbs{$_}\n";                                                \\
}                                                                               \\
 '"'" 
alias idoldatabases             idoldbs
    

############################################
# IDOL Categories and Auto-Classification
############################################


alias idolcat               'curl "$DEVURL=CategoryGetDetails&Category=\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolcaturi            'curl "$DEVURL=CategoryFindByFields&Fields=ts_urn&Values=trim:$var_idolDBID/pln/\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idoltraining          'curl "$DEVURL=CategoryGetTraining&Category=\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolsuggesturi        'curl "$DEVURL=categorySuggestfromDocument&DocRef=trim:$var_idolDBID/rec/\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolsuggesttrim       'curl "$DEVURL=categorySuggestfromDocument&DocRef=trim:$var_idolDBID/rec/\!^&DatabaseMatch=$var_idolDb&FieldText=MATCH%7BTRUE%7D:TB_CANHAVERECS&PrintFields=TS_URN&NumResults=1" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolcategoryids       'curl "$DEVURL=CategoryFindByFields&Fields=tb_canhaverecs&Values=TRUE" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl '
alias idolcatids            idolcategoryids        
alias idolterms             'curl "$DEVURL=CategoryGetTNW&Category=\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolcatdelete         'curl "$DEVURL=CategoryDelete&Category=\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolcatdel            idolcatdelete
alias idolcatdelete_all     idolcatdel 0
alias idolcathierarchy      'curl "$DEVURL=CategoryGetHierDetails&Category=\!^" --noproxy "*" --silent | \\
                            $PERL $PERL_HOME/xmlformat.pl'
alias idolcathier           idolcathierarchy
alias idolclassifications   'setenv IDOL_DEV_URL $DEVURL && idolcategoryids |                                        \\
                            $PERL -ne "/id>(\d+)<\/autn/ and do { s/^\s+<autn:id>//; s/<\/autn.+//; print};"  |     \\
                            $PERL -ne  ' "' "' chomp;print "ID = $_\n";                                             \\
                            print `curl "$ENV{'IDOL_DEV_URL'}=CategoryGetDetails&Category=$_" --noproxy "*" --silent`  '"'"

alias idolcaturis           'setenv IDOL_DEV_URL $DEVURL && idolcategoryids |                                           \\
                            $PERL -ne "/id>(\d+)<\/autn/ and do { s/^\s+<autn:id>//; s/<\/autn.+//; print};"            \\
| $PERL -ne  ' "' "'                                                                                                    \\
chomp;                                                                                                                  \\
$ID =  $_;                                                                                                              \\
$input = `curl "$ENV{'IDOL_DEV_URL'}=CategoryGetDetails&Category=$_" --noproxy "*" --silent`;                           \\
if($input =~ /<autn:name>(.+)<\/autn:name>/) { print "CATEGORY => $1\n"; }                                              \\
if($input =~ /<autn:ts_urn>trim:..\/pln\/(\d+)<\/autn:ts_urn>/) { print "\tURI : $1\n"; }                               \\
print "\tID  : $ID\n\n";                                                                                                \\
'"'"

alias idolall             'idolclass all'
alias idolclass               'setenv IDOL_CLS_PARAMS "\!*" && idolclassifications              \\
| $PERL $PERL_HOME/xmlformat.pl                                                                 \\
| $PERL -e ' "' "'                                                                              \\
                                                                                                \\
sub printTerms($$){                                                                             \\
  ($terms,$max) = @_;                                                                           \\
  $i=1;                                                                                         \\
  $ts = "";                                                                                     \\
  for(@$terms){                                                                                 \\
    if($i % 5 == 0){ $ts .= "\n"; }                                                             \\
    my $t = $_->{word}.":".$_->{weight};                                                        \\
    my $sp = " " x ($max - length($t) + 1);                                                     \\
    $ts .= $t.$sp;                                                                              \\
    $i++;                                                                                       \\
  }                                                                                             \\
  if(length($ts) > 0) { print "$ts\n"; }                                                        \\
  print "\n";                                                                                   \\
}                                                                                               \\
                                                                                                \\
my ($currentID,%CLASSES);                                                                       \\
my $opts = $ENV{'IDOL_CLS_PARAMS'};                                                             \\
@input = <STDIN>;                                                                               \\
for($i = 0; $i<$#input; $i++){                                                                  \\
  $l = $input[$i]; chomp $l;                                                                    \\
  if($l =~ /^ID = (\d+)$/){ $currentID = $1; next; }                                            \\
  if($l =~ /<response>SUCCESS<\/response>/){                                                    \\
    my $name = $input[$i + 3];                                                                  \\
    my $db = $input[$i + 5];                                                                    \\
    my $terms = $input[$i + 6];                                                                 \\
    my $urn = $input[$i + 9];                                                                   \\
    $name   =~ s/^.*autn:name.(.+).\/autn:name..*$/$1/; chomp $name;                            \\
    $db     =~ s/^.*autn:databases.(.+).\/autn:databases..*$/$1/; chomp $db;                    \\
    $terms  =~ s/^.*autn:queryagenttnw.(.+).\/autn:queryagenttnw..*$/$1/; chomp $terms;         \\
    if($terms =~ /autn:categoryparameters/) { # There are no terms                              \\
      $terms = 0;                                                                               \\
      $urn = $input[$i + 8];                                                                    \\
    }                                                                                           \\
                                                                                                \\
    $urn    =~ s/^.*autn:ts_urn.(.+).\/autn:ts_urn..*$/$1/; chomp $urn;                         \\
    my $longest = 10;                                                                           \\
    @terms = split(/\]\s+/, $terms);                                                            \\
    my @new;                                                                                    \\
                                                                                                \\
    if($terms){                                                                                 \\
      for(@terms){                                                                              \\
        if(/^(.+)~\[(\d+)$/){                                                                   \\
          ($word,$val) = ($1,$2);                                                               \\
          my $tmp = "$word:$val";                                                               \\
          $longest = length($tmp) > $longest ? length($tmp) : $longest;                         \\
          push @new, { word => $word, weight => $val };                                         \\
        }                                                                                       \\
        elsif(/^(.+)~\[(\d+)\]$/){   # Last term in list                                        \\
          ($word,$val) = ($1,$2);                                                               \\
          my $tmp = "$word:$val";                                                               \\
          $longest = length($tmp) > $longest ? length($tmp) : $longest;                         \\
          push @new, { word => $word, weight => $val };                                         \\
        }                                                                                       \\
        else { print "BAD SPLIT : $_\n"; }                                                      \\
      }                                                                                         \\
    }                                                                                           \\
    else { @new = (); }                                                                         \\
                                                                                                \\
    if($urn =~ /trim:(..)\/pln\/(\d+)/){                                                        \\
      $CLASSES{$2} = {                                                                          \\
         id    => $currentID, uri => $2,   name => $name,  db => $db,                           \\
         terms => \@new,      urn => $urn, max => $longest                                      \\
      };                                                                                        \\
    }                                                                                           \\
    else{                                                                                       \\
      print "BAD URN VALUE: $urn\n";                                                            \\
    }                                                                                           \\
    $i = $i + 12; # Move to next entry                                                          \\
  }                                                                                             \\
}                                                                                               \\
                                                                                                \\
# Deal with options                                                                             \\
if($opts =~ /^s(ummary)*$/i){                                                                   \\
  for(sort keys %CLASSES){                                                                      \\
    $i = $CLASSES{$_};                                                                          \\
    print "ID:".$i->{id}.", URI:".$_ ." => ".$i->{name}."\n";                                   \\
  }                                                                                             \\
}                                                                                               \\
elsif($opts =~ /^a(ll)*$/i){                                                                    \\
  for(keys %CLASSES){                                                                           \\
    $cls = $CLASSES{$_};                                                                        \\
    print "=================================================== \n";                             \\
    print "NAME      : ".$cls->{name}."\n";                                                     \\
    print "URN (DB)  : ".$cls->{urn}." (".$cls->{db}.")\n";                                     \\
    print "CAT ID    : ".$cls->{id}."\n";                                                       \\
    print "TERMS     : ".scalar(@{$cls->{terms}})."\n";                                         \\
    printTerms($cls->{terms},$cls->{max});                                                      \\
  }                                                                                             \\
}                                                                                               \\
elsif($opts =~ /^\d+$/){                                                                        \\
  if(exists $CLASSES{$opts}){                                                                   \\
    $cls = $CLASSES{$opts};                                                                     \\
    print "=================================================== \n";                             \\
    print "NAME      : ".$cls->{name}."\n";                                                     \\
    print "URN (DB)  : ".$cls->{urn}." (".$cls->{db}.")\n";                                     \\
    print "CAT ID    : ".$cls->{id}."\n";                                                       \\
    print "TERMS     :\n";                                                                      \\
    printTerms($cls->{terms},$cls->{max});                                                      \\
  }                                                                                             \\
}                                                                                               \\
elsif($opts =~ /^[\w-\.]+$/){                                                                   \\
  for(keys %CLASSES){                                                                           \\
    $cls = $CLASSES{$_};                                                                        \\
    if($cls->{name} =~ /$opts/i){                                                               \\
      print "=================================================== \n";                           \\
      print "URI       : ".$cls->{uri}."\n";                                                    \\
      print "NAME      : ".$cls->{name}."\n";                                                   \\
      print "URN (DB)  : ".$cls->{urn}." (".$cls->{db}.")\n";                                   \\
      print "CAT ID    : ".$cls->{id}."\n";                                                     \\
      print "TERMS     :\n";                                                                    \\
      printTerms($cls->{terms},$cls->{max});                                                    \\
    }                                                                                           \\
  }                                                                                             \\
}                                                                                               \\
                                                                                                \\
'"'"
 
