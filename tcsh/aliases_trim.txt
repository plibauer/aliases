##################################################################################################################
#                                                                                                                #
#     TRIM Specific aliases                                                                                      #
#     This file should only be read once.                                                                        #
#                                                                                                                #
##################################################################################################################

#
#
alias tes        						'$var_trimDir/$var_defArch/$var_defBuild/TRIMEnterpriseStudio.exe &'
alias trim       						'$var_trimDir/$var_defArch/$var_defBuild/TRIM.exe &'
alias trimhelp   						'hh $var_trimDir/doc/doc/DocPub/TRIM.chm &'
alias wgs        						'$var_trimDir/$var_defArch/$var_defBuild/TRIMWorkgroup.exe &'
alias messages      					'cat $var_trimDir/trim/TRIMMessages.txt | pgrep -i '
alias trimmessages  					'$var_trimDir/trim/TRIMMessages.exe'
alias properties    					'cat $var_trimDir/trim/src/DD/properties.txt | pgrep -i '
alias viewprop      					'view $var_trimDir/trim/src/DD/properties.txt'
alias propids       					'cat $var_trimDir/trim/src/HP.HPTRIM.SDK/swig/PropertyIds.cs | pgrep -i '
alias propidx       					'cat $var_trimDir/trim/src/Core/PRPpropertyFind.cpp | pgrep -i '

alias database      					'cat $var_trimDir/trim/src/DD/DATABASE.TXT | pgrep -i '
alias viewdb        					'view $var_trimDir/trim/src/DD/DATABASE.TXT'

alias killtrim							'taskkill /F /IM TRIM.exe'
alias killwgs 							'taskkill /F /IM TRIMWorkgroup.exe'
alias killproc							'taskkill /F /IM'
alias killboth							'killtrim;killwgs'

# Run populate database
alias populatedb 						'cd $var_trimDir; $var_trimDir/$var_defArch/$var_defBuild/PopulateDatabase.exe'
alias popdb 							populatedb
alias popdbhelp							'populatedb -h'
alias restorepopdb 						'popdb --load --dbid $var_DBID --dbname $var_dbSession'
alias reloadpopdb 						restorepopdb
alias defaultconfig						'setdbid $env_default_dbid; dbsession $dbDefault'
alias elasticconfig						defaultconfig
alias popdboracle 						'popdb --db oracle64'
alias popdbidol         				'populatedb --dci idol --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol"; bkupidolcfg'
alias restoreidol						'popdb --load --dci idol --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol"'
alias idolconfig						'setdbid $env_default_dbid_pref"5"; dbsession $var_dbSession"_idol"'
alias popdbbig							'popdb --big'
alias bigconfig							'setdbid 41; dbsession Test_Big_"$env_revision"_SqlServer'
alias popdbelastic						'popdb --dciServer $var_elasticHost --snapshotPath "/usr/share/elasticsearch/data/snapshots"'
alias popdbes							popdbelastic

alias testac            				'testtrim --test autoclassification'
alias elk_train         				'testac --load train '
alias elk_test          				'testac --load test --inplace'
alias elk_both          				'testac --load both '
alias elk_classify      				'testac --inplace --classify '
alias elastic_train						elk_train
alias elastic_test						elk_test
alias elastic_both						elk_both
alias elastic_classify					elk_classify

alias idol_train						'testac --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol" --load train'
alias idol_test  						'testac --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol" --load test --inplace'
alias idol_both         				'testac --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol" --load both'
alias idol_classify     				'testac --dbid $env_default_dbid_pref"5" --dbname $var_dbSession"_idol" --classify --inplace'

alias trimconfig       					'xmlconf $var_trimcfg'
alias trimcfgsorted   					'xmlformat $var_trimcfg | $PYTHON $PYTHON_HOME/sortXml.py'
alias restoreconfig    					'cp /c/TestDatasets/$var_DBID/backup/TRIMConfig.tcfg $var_trimcfgdir'
alias xmltrim          					'xmlformat $var_trimcfg'
alias getconfig        					'more $var_trimcfg'
alias fixtrimconfig    					'xmlformat -i -b .backup $var_trimcfg'
alias bkupidolcfg      					'cp $var_trimcfg /c/TestDatasets/$var_DBID/backup/TRIMConfig.tcfg.IDOL'
alias bkupelasticcfg   					'cp $var_trimcfg /c/TestDatasets/$var_DBID/backup/TRIMConfig.tcfg.ELASTIC'
alias idolcfg          					'cp /c/TestDatasets/$var_DBID/backup/TRIMConfig.tcfg.IDOL $var_trimcfg'
alias elasticcfg       					'cp /c/TestDatasets/$var_DBID/backup/TRIMConfig.tcfg.ELASTIC $var_trimcfg'

alias testtrim       					'$var_trimDir/$var_defArch/$var_defBuild/testTrim.exe'
alias trimtest       					testtrim
alias testhelp	     					'testtrim --help'
alias testlist       					'testtrim --list'
alias testcases      					testlist
alias bld            					'testtrim --test bulkLoader --type all --timeout 6000 --assert'
alias bldapi         					'testtrim --test bulkLoader --type api --timeout 6000 --assert'
alias bldsth         					'testtrim --test bulkLoader --type sth --timeout 6000 --assert'
alias bldrecs        					'testtrim --test bulkLoader --type apirec --timeout 6000 --assert'
alias bldcont        					'testtrim --test bulkLoader --type container --timeout 6000 --assert'
alias makecontainers 					'testtrim --test bulkLoader --type container --timeout 6000 --assert --inplace --containers \!:1 --perContainer \!:2'

# CSharp testing
alias testcs       						'$var_trimDir/AnyCPU/$var_defBuild/TestTrimCs.exe --test'
alias testevmon	   						'testcs EventMonitor --inplace'

# OCTANE
alias curldefect						'curl -s "$var_elasticHost/octane_new/_search?pretty&q=\!^"'
alias defect							'$PYTHON $PYTHON_HOME/octane.py'
alias defectall							'$PYTHON $PYTHON_HOME/octane.py -v'
alias cr								defect
alias crall								defectall
alias crv								defectall
alias currentdefects					'$PYTHON_CYG $PYTHON_HOME/curl.py "$var_elasticHost/octane_new/_search?pretty" -c current_defects -f $ELASTIC_QUERIES \!^'
alias defectprocessor                   '$PERL -e ' "'" ' \\
use Term::ANSIColor qw(:constants :constants256);                     \\
sub parse {                                                           \\
  my $l = shift;                                                      \\
  chomp $l;                                                           \\
  $l =~ s/^\s+\"(\w+)\"\s+:\s+//;                                     \\
  my $field = $1;                                                     \\
  $l =~ s/^"//;                                                       \\
  $l =~ s/"?,*\s*$//;                                                 \\
  return ($field,$l);                                                 \\
}                                                                     \\
@IN = <>;                                                             \\
my $VERBOSE = 0;                                                      \\
if($ENV{DEFECT_OUTPUT} eq "verbose"){ $VERBOSE = 1;}                  \\
#print "RELEASE: ID [phase,severity,priority,defect_type] Summary\n"; \\
my (%ids,%releases);                                                  \\
while(my $l = shift @IN) {                                            \\
  if($l =~ /"_id.+:\s+"(\w+)"/) {                                     \\
    my $id = $1;                                                      \\
    my ($ph,$lm,$sev,$rel,$name,$pr,$det,$typ,$cl,$qa);               \\
    while ($l = shift @IN) {                                          \\
      if( $l =~ /^\s+"_id"/ ) {                                       \\
         unshift @IN, $l;                                             \\
         last;                                                        \\
      }                                                               \\
      my ($f,$val) = parse($l);                                       \\
      #print "F:$f, VAL:$val\n";                                      \\
      $f =~ /^(_qa_owner)$/ and do {                                  \\
         $qa = $val;                                                  \\
      };                                                              \\
      $f =~ /^(closed_on)$/ and do {                                  \\
         $cl = $val;                                                  \\
      };                                                              \\
      $f =~ /^(name)$/ and do {                                       \\
         $name = $val;                                                \\
      };                                                              \\
      $f =~ /^(_release)$/ and do {                                   \\
         $rel = $val;                                                 \\
      };                                                              \\
      $f =~ /^(_defect_type)$/ and do {                               \\
         $typ = $val;                                                 \\
      };                                                              \\
      $f =~ /^(_phase)$/ and do {                                     \\
         $ph = $val;                                                  \\
      };                                                              \\
      $f =~ /^(last_modified)$/ and do {                              \\
         $lm = $val;                                                  \\
      };                                                              \\
      $f =~ /^(_detected_in_release)$/ and do {                       \\
         $det = $val;                                                 \\
      };                                                              \\
      $f =~ /^(_severity)$/ and do {                                  \\
         $sev = $val;                                                 \\
      };                                                              \\
      $f =~ /^(_priority)$/ and do {                                  \\
         $pr = $val;                                                  \\
      };                                                              \\
    }                                                                 \\
                                                                      \\
    $rel =~ s/^9.50.+$/10.00/;                                        \\
    $rel =~ s/^(\d+)\.(\d)\s/$1.$+0 /;                                \\
    $rel =~ s/^(\d+)\.(\d)$/$1.$+0/;                                  \\
    # Remove any escaped double quotes from the title                 \\
    $name =~ s/\\"/"/g;                                               \\
    #print "ID:$id\nPH:$ph\nSEV:$sev\nREL:$rel\nNAM:$name\nPR:$pr\nDET:$det\nTYP:$typ\n\n"; \\
    $ids{$id} = { id          => $id,                                 \\
                  phase       => $ph,                                 \\
                  severity    => $sev,                                \\
                  release     => $rel,                                \\
                  name        => $name,                               \\
                  priority    => $pr,                                 \\
                  detected_in => $det,                                \\
                  type        => $typ };                              \\
    push @{$releases{$rel}}, $id;                                     \\
  }                                                                   \\
}                                                                     \\
my $SPACE = length("[Awaiting Decision,Critical,Very High,Enhancement]"); \\
for(sort keys %releases) {                                            \\
  my $rel = $_;                                                       \\
  s/^.+"([\s\w\d\.]+)".*$/$1/;                                        \\
  print BOLD, YELLOW, "\nTarget Release:$_\n", RESET;                 \\
  my %defects;                                                        \\
  foreach(@{$releases{$rel}}) {                                       \\
    my $id = $_;                                                      \\
    my $lead = "[".$ids{$id}{phase}.                                  \\
               ",".$ids{$id}{severity}.                               \\
               ",".$ids{$id}{priority}.                               \\
               ",".$ids{$id}{type}."] ";                              \\
    my $sp = " "x($SPACE - length($lead));                            \\
    my $summary = $ids{$id}{name};                                    \\
    my $shortSum = substr $summary, 0, 80;                            \\
    if($VERBOSE) {                                                    \\
      if(length($summary) > 80) {                                     \\
        $defects{$id} = $lead.$sp.$shortSum." ...";                   \\
      }                                                               \\
      else { $defects{$id} = $lead.$sp.$summary;  }                   \\
    }                                                                 \\
    else {                                                            \\
      $defects{$id} = $summary;                                       \\
    }                                                                 \\
  }                                                                   \\
  foreach(reverse sort keys %defects) {                               \\
    print BOLD, CYAN, "  $_: ", RESET,$defects{$_}."\n";              \\
  }                                                                   \\
}                                                                     \\
' "'"
alias defectsuser						'currentdefects \!^ | egrep "_id|_phase|_severity|_release|name|_priority|_defect_type" | defectprocessor '
alias defects							'defectsuser paul.libauer'
alias defectsuserv					    'setenv DEFECT_OUTPUT "verbose"; currentdefects \!^ | egrep "_id|_phase|_severity|_release|_name|_priority|_defect_type" | defectprocessor ; unsetenv DEFECT_OUTPUT'

alias defectsv							'defectsuserv paul.libauer'

alias enums  'cat $var_trimDir/trim/src/HP.HPTRIM.SDK/swig/PropertyIds.cs     \\
| $PERL -e ' "'" '                                                            \\
while(<>){                                                                    \\
  if(/^\s*(\w+)\s*=\s*(\d+)\s*,/){                                            \\
    if($ids{$2}){                                                             \\
       print "DUPLICATE? => $2\n";                                            \\
       next;                                                                  \\
    }                                                                         \\
    $ids{$2}=$1;                                                              \\
  }                                                                           \\
}                                                                             \\
my $max = (reverse sort {$a<=>$b} keys %ids)[0];                              \\
for my $i (0 .. $max) {                                                       \\
  if($ids{$i}){                                                               \\
    print "$i\t".$ids{$i}."\n";                                               \\
  }                                                                           \\
  else {                                                                      \\
    print "$i\n";                                                             \\
  }                                                                           \\
}                                                                             \\
' "'"

alias trimtables 'cat $var_trimDir/trim/src/DD/DATABASE.TXT                   \\
| $PERL -e ' "'" '                                                            \\
@in = <>;                                                                     \\
my %tables;                                                                   \\
my $max = 10;                                                                 \\
for(@in) {                                                                    \\
  chomp;                                                                      \\
  s/nouri//gi;                                                                \\
  s/basic(plusloc)*\s+\[/[/gi;                                                \\
  s/sharedbobtype\(\w+\)//i;                                                  \\
  s/sharedtableid\(\w+\)//i;                                                  \\
  s/shared\([\w,\s]+\)//i;                                                    \\
  s/obsoleteafter\(\d+\)//i;                                                  \\
  s/^(table\s+[\d,\s]+)iot /$1/i;                                             \\
  /^table\s+[\d,\s]+(\w+)[\s\d\%]+\[(.+)\]/ and do {                          \\
     $tables{uc $1} = $2;                                                     \\
     $l = length $1;                                                          \\
     $max = ($l > $max) ? $l : $max;                                          \\
  }                                                                           \\
}                                                                             \\
for(sort keys %tables) {                                                      \\
   $sp = $max - length($_);                                                   \\
   print $_.(" " x $sp).": ".$tables{$_}."\n";                                \\
}                                                                             \\
' "'" 
alias tableinfo trimtables

alias shorttables 'trimtables |                  \\
$PERL -ne  '"'"'                                 \\
/^(\w{1,8})\w*\s*:(.+)$/ and do {                \\
  $sp = 8 - length($1);                          \\
  print  "TS$1".(" " x $sp)." :$2\n"             \\
} '"'" 

alias whichcfg 'cat $var_trimcfg |               \\
$PERL -e ' "'" '                                 \\
while (<>) {                                     \\
  if ($_ =~ /ElasticUrl>(.*)<\/Elastic/) {       \\
     if ($1 =~ /^http/i) {                       \\
         print "ELASTIC\n";                      \\
         exit                                    \\
     }                                           \\
  }                                              \\
}                                                \\
print "IDOL\n"  ' "'"
